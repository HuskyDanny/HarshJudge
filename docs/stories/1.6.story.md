# Story 1.6: Implement `startRun` MCP Tool

## Status

Done

## Story

**As a** Claude Code user,
**I want** to start a new test run,
**so that** I have a dedicated directory for capturing evidence.

## Acceptance Criteria

1. `startRun` tool registered in MCP server with proper schema
2. Tool accepts parameter: `scenarioSlug` (required)
3. Tool validates scenario exists
4. Tool generates unique run ID using nanoid
5. Tool creates run directory: `.harshJudge/scenarios/{slug}/runs/{runId}/`
6. Tool creates `evidence/` subdirectory within run
7. Tool records start timestamp
8. Tool returns `runId`, `runPath`, `evidencePath`, `runNumber`
9. Unit tests verify directory creation and ID generation

## Tasks / Subtasks

- [x] **Task 1: Add nanoid dependency** (AC: 4)
  - [x] Add `nanoid` package to mcp-server
  - [x] Run `pnpm install`

- [x] **Task 2: Implement startRun handler** (AC: 1, 2, 3, 4, 5, 6, 7, 8)
  - [x] Create `packages/mcp-server/src/handlers/start-run.ts`
  - [x] Import `StartRunParamsSchema` from `@harshjudge/shared`
  - [x] Validate input parameters using Zod schema
  - [x] Check if project is initialized
  - [x] Check if scenario exists
  - [x] Generate unique run ID using nanoid
  - [x] Calculate run number (count existing runs + 1)
  - [x] Create run directory: `.harshJudge/scenarios/{slug}/runs/{runId}/`
  - [x] Create `evidence/` subdirectory
  - [x] Return `StartRunResult` with runId, paths, runNumber, startedAt

- [x] **Task 3: Update mcp-server exports** (AC: 1)
  - [x] Export `handleStartRun` from `index.ts`

- [x] **Task 4: Write unit tests for startRun handler** (AC: 9)
  - [x] Create `packages/mcp-server/tests/handlers/start-run.test.ts`
  - [x] Test successful run start with valid scenario
  - [x] Test error when project not initialized
  - [x] Test error when scenario does not exist
  - [x] Test unique run ID generation (mocked nanoid)
  - [x] Test run directory and evidence subdirectory creation
  - [x] Test correct run number calculation
  - [x] Test startedAt timestamp is valid ISO string

- [x] **Task 5: Verify build and tests pass** (AC: 1-9)
  - [x] Run `pnpm build` to verify compilation
  - [x] Run `pnpm test` to verify all tests pass
  - [x] Run `pnpm typecheck` to verify types
  - [x] Run `pnpm lint` to verify code quality

## Dev Notes

### Previous Story Insights
[Source: docs/stories/1.5.story.md#Dev Agent Record]

From Story 1.5 implementation:
- `FileSystemService` with `listDirs()` method available for counting existing runs
- Handler pattern established with dependency injection for testing
- All handlers use Zod validation from `@harshjudge/shared`
- Tests use memfs for filesystem mocking

### Handler Implementation Pattern
[Source: architecture/10-backend-architecture-mcp-server.md]

```typescript
// packages/mcp-server/src/handlers/start-run.ts
import { nanoid } from 'nanoid';
import {
  StartRunParamsSchema,
  type StartRunResult,
} from '@harshjudge/shared';
import { FileSystemService } from '../services/file-system-service.js';

const HARSH_JUDGE_DIR = '.harshJudge';
const SCENARIOS_DIR = 'scenarios';
const RUNS_DIR = 'runs';
const EVIDENCE_DIR = 'evidence';

/**
 * Starts a new test run for a scenario.
 * Creates run directory with evidence subdirectory.
 */
export async function handleStartRun(
  params: unknown,
  fs: FileSystemService = new FileSystemService()
): Promise<StartRunResult> {
  // 1. Validate input parameters
  const validated = StartRunParamsSchema.parse(params);

  // 2. Check if project is initialized
  if (!(await fs.exists(HARSH_JUDGE_DIR))) {
    throw new Error('Project not initialized. Run initProject first.');
  }

  // 3. Check if scenario exists
  const scenarioDir = `${HARSH_JUDGE_DIR}/${SCENARIOS_DIR}/${validated.scenarioSlug}`;
  if (!(await fs.exists(scenarioDir))) {
    throw new Error(`Scenario "${validated.scenarioSlug}" does not exist.`);
  }

  // 4. Generate unique run ID
  const runId = nanoid(10); // 10 character ID

  // 5. Calculate run number
  const runsDir = `${scenarioDir}/${RUNS_DIR}`;
  let runNumber = 1;
  if (await fs.exists(runsDir)) {
    const existingRuns = await fs.listDirs(runsDir);
    runNumber = existingRuns.length + 1;
  }

  // 6. Create run directory structure
  const runPath = `${runsDir}/${runId}`;
  const evidencePath = `${runPath}/${EVIDENCE_DIR}`;
  await fs.ensureDir(runPath);
  await fs.ensureDir(evidencePath);

  // 7. Record start timestamp
  const startedAt = new Date().toISOString();

  // 8. Return result
  return {
    success: true,
    runId,
    runNumber,
    runPath,
    evidencePath,
    startedAt,
  };
}
```

### Directory Structure After startRun
[Source: architecture/8-database-schema.md#81-directory-structure-schema]

```
.harshJudge/
├── config.yaml
├── .gitignore
└── scenarios/
    └── {scenario-slug}/
        ├── scenario.md
        ├── meta.yaml
        └── runs/                    # Created if not exists
            └── {runId}/             # Created by startRun
                └── evidence/        # Created by startRun
```

### Shared Types Available
[Source: packages/shared/src/types/mcp-tools.ts]

```typescript
// Already defined in @harshjudge/shared
export const StartRunParamsSchema = z.object({
  scenarioSlug: z.string().regex(/^[a-z0-9-]+$/),
});

export interface StartRunResult {
  success: boolean;
  runId: string;
  runNumber: number;
  runPath: string;
  evidencePath: string;
  startedAt: string;
}
```

### Dependencies to Add
[Source: architecture/3-tech-stack.md]

| Technology | Version | Purpose |
|------------|---------|---------|
| nanoid | 5+ | Unique ID generation |

**Add to `packages/mcp-server/package.json`:**
```json
{
  "dependencies": {
    "nanoid": "^5.0.9"
  }
}
```

### File Locations
[Source: architecture/11-unified-project-structure.md]

**Files to create:**
```
packages/mcp-server/
├── src/
│   └── handlers/
│       └── start-run.ts          # Handler implementation
└── tests/
    └── handlers/
        └── start-run.test.ts     # Handler tests
```

### Testing Strategy
[Source: architecture/15-testing-strategy.md]

```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { vol } from 'memfs';
import { handleStartRun } from '../../src/handlers/start-run.js';
import { FileSystemService } from '../../src/services/file-system-service.js';

vi.mock('fs/promises', async () => {
  const memfs = await import('memfs');
  return memfs.fs.promises;
});

// Mock nanoid for predictable IDs in tests
vi.mock('nanoid', () => ({
  nanoid: () => 'test-run-id',
}));

describe('handleStartRun', () => {
  let fs: FileSystemService;

  beforeEach(() => {
    vol.reset();
    // Create initialized project with scenario
    vol.mkdirSync('/project/.harshJudge/scenarios/login-test', { recursive: true });
    vol.writeFileSync('/project/.harshJudge/scenarios/login-test/scenario.md', '# Test');
    vol.writeFileSync('/project/.harshJudge/scenarios/login-test/meta.yaml', 'totalRuns: 0');
    fs = new FileSystemService('/project');
  });

  it('creates run directory with evidence subdirectory', async () => {
    const result = await handleStartRun({ scenarioSlug: 'login-test' }, fs);

    expect(result.success).toBe(true);
    expect(result.runId).toBe('test-run-id');
    expect(vol.existsSync('/project/.harshJudge/scenarios/login-test/runs/test-run-id')).toBe(true);
    expect(vol.existsSync('/project/.harshJudge/scenarios/login-test/runs/test-run-id/evidence')).toBe(true);
  });

  it('throws error if scenario does not exist', async () => {
    await expect(
      handleStartRun({ scenarioSlug: 'nonexistent' }, fs)
    ).rejects.toThrow('does not exist');
  });

  it('calculates correct run number', async () => {
    // First run
    const result1 = await handleStartRun({ scenarioSlug: 'login-test' }, fs);
    expect(result1.runNumber).toBe(1);

    // Create another run manually to test increment
    vol.mkdirSync('/project/.harshJudge/scenarios/login-test/runs/existing-run', { recursive: true });

    const result2 = await handleStartRun({ scenarioSlug: 'login-test' }, fs);
    expect(result2.runNumber).toBe(3); // test-run-id + existing-run + new one
  });
});
```

### Coding Standards
[Source: architecture/16-coding-standards.md]

- **File Operations:** All file operations go through `FileSystemService`
- **ID Generation:** Use nanoid for unique, URL-safe IDs
- **Validation:** All MCP tool inputs must be validated with Zod before processing
- **File Names:** kebab-case (`start-run.ts`, `start-run.test.ts`)

### Validation Commands
```bash
pnpm install          # Install nanoid dependency
pnpm build            # Verify compilation
pnpm test             # Verify all tests pass
pnpm typecheck        # Verify type checking
pnpm lint             # Verify linting
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-04 | 1.0 | Initial story draft | SM Agent (Bob) |

---

## Dev Agent Record

### Agent Model Used

Claude Opus 4.5 (claude-opus-4-5-20251101)

### Debug Log References

No debug issues encountered.

### Completion Notes List

- Added `nanoid@^5.0.9` dependency for unique ID generation
- Implemented `handleStartRun` handler:
  - Validates scenario exists before starting run
  - Generates 10-character URL-safe run ID using nanoid
  - Calculates run number by counting existing run directories
  - Creates run directory with evidence subdirectory
  - Records ISO timestamp for startedAt
- Handler accepts optional `FileSystemService` for dependency injection in tests
- Created comprehensive unit tests (15 tests for startRun handler)
- Tests mock nanoid for predictable IDs
- All validation commands passed:
  - `pnpm build` - 3 packages built successfully
  - `pnpm test` - 83 tests passing (16 shared + 66 mcp-server + 1 ux)
  - `pnpm typecheck` - No type errors
  - `pnpm lint` - No linting errors

### File List

**New Files:**
- `packages/mcp-server/src/handlers/start-run.ts` - startRun handler
- `packages/mcp-server/tests/handlers/start-run.test.ts` - Handler tests (15 tests)

**Modified Files:**
- `packages/mcp-server/package.json` - Added nanoid dependency
- `packages/mcp-server/src/index.ts` - Added export for handleStartRun
- `pnpm-lock.yaml` - Updated with nanoid

---

## QA Results

### QA Agent: Quinn
### Date: 2025-12-04
### Verdict: ✅ PASS

### Acceptance Criteria Verification

| AC | Criteria | Status | Notes |
|----|----------|--------|-------|
| 1 | `startRun` tool registered in MCP server with proper schema | ✅ | Handler exported from `index.ts` |
| 2 | Tool accepts parameter: `scenarioSlug` (required) | ✅ | Uses `StartRunParamsSchema` |
| 3 | Tool validates scenario exists | ✅ | Throws error with slug name if not found |
| 4 | Tool generates unique run ID using nanoid | ✅ | Uses `nanoid(10)` for 10-char ID |
| 5 | Tool creates run directory: `.harshJudge/scenarios/{slug}/runs/{runId}/` | ✅ | Verified in tests |
| 6 | Tool creates `evidence/` subdirectory within run | ✅ | Verified in tests |
| 7 | Tool records start timestamp | ✅ | Returns ISO timestamp in `startedAt` |
| 8 | Tool returns `runId`, `runPath`, `evidencePath`, `runNumber` | ✅ | Returns complete `StartRunResult` |
| 9 | Unit tests verify directory creation and ID generation | ✅ | 15 tests with mocked nanoid |

### Validation Commands

```
pnpm build     ✅ PASS
pnpm test      ✅ 83 tests passing (16 shared + 66 mcp-server + 1 ux)
pnpm typecheck ✅ PASS
pnpm lint      ✅ PASS
```

### Code Quality Assessment

- ✅ **SOLID**: Dependency injection for FileSystemService
- ✅ **KISS**: Simple, focused implementation
- ✅ **DRY**: Reuses existing FileSystemService methods (listDirs)
- ✅ **Error Handling**: Validates project init and scenario existence
- ✅ **Testing**: nanoid mocked for deterministic test IDs

### Test Coverage

- startRun handler: 15 tests covering:
  - Successful run start (6 tests)
  - Error handling (6 tests)
  - Edge cases (3 tests)

### Notes

Good use of `listDirs()` for counting existing runs. Proper validation order: project first, then scenario. The nanoid mocking strategy is clean and effective for testing.
